## Задание 3

1. Создайте таблицу с большим количеством данных:
    ```sql
    CREATE TABLE test_cluster AS 
    SELECT 
        generate_series(1,1000000) as id,
        CASE WHEN random() < 0.5 THEN 'A' ELSE 'B' END as category,
        md5(random()::text) as data;
    ```

2. Создайте индекс:
    ```sql
    CREATE INDEX test_cluster_cat_idx ON test_cluster(category);
    ```

3. Измерьте производительность до кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    "Bitmap Heap Scan on test_cluster  (cost=5584.33..20226.24 rows=500633 width=39) (actual time=15.921..56.961 rows=499631 loops=1)"
    "Recheck Cond: (category = 'A'::text)"
    "Heap Blocks: exact=8334"
    "->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..5459.17 rows=500633 width=0) (actual time=14.651..14.651 rows=499631 loops=1)"
    "Index Cond: (category = 'A'::text)"
    "Planning Time: 0.086 ms"
    "Execution Time: 70.882 ms"
    ```
    
    *Объясните результат:*
    Так как данных много, оптимизатор принимает решение провести битмап сканирование для сортировки, отфильтровывая строки, не соответствующие условию. Далее, проходит перепроверка по условию. Heap Blocks означает, что 8334 фрагментов были построены с точностью до строк - по ним перепроверка не проходит.
    После этого, по битмапу проходит созданный нами индекс, который выявляет строки по заданному условию. Можно заметить, что ввиду большого количества данных, скорость запроса является довольно медленной.

4. Выполните кластеризацию:
    ```sql
    CLUSTER test_cluster USING test_cluster_cat_idx;
    ```
    
    *Результат:*
    ```
    CLUSTER

    Query returned successfully in 707 msec.
    ```

5. Измерьте производительность после кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    "Index Scan using test_cluster_cat_idx on test_cluster  (cost=0.42..14660.92 rows=501400 width=39) (actual time=0.034..39.812 rows=499631 loops=1)"
    "Index Cond: (category = 'A'::text)"
    "Planning Time: 0.096 ms"
    "Execution Time: 53.685 ms"
    ```
    
    *Объясните результат:*
    Можно заметить, что оптимизатор использовал индексное сканирование вместо того, что было в предыдущем запросе, так как здесь используются кластеризованные данные.
    Проводя поиск по кластеризованной таблице, скорость запроса становится немного более быстрой. Это объясняется тем, что кластеризация меняет физическое положение данных в таблице, которые помогают оптимизировать запрос. Головка диска, которая ездит по диску и собирает нужные строки, в случае некластеризованных данных, ездит по диску и собирает необходимые данные. Процесс кластеризации оптимизирует данный процесс, что и позволяет ускорить его относительно предыдущего запроса.

6. Сравните производительность до и после кластеризации:
    
    *Сравнение:*
    Так как данных очень много, то прирост производительность несущественный, но он присутствует. Например, время запроса уменьшилось с 70мс до 50мс, что является следствием кластеризации данных и использования индекса. Помимо этого, сильно уменьшились косты (условная единица затраченного ресурса на выполнение запроса): общая стоимость шага уменьшилась примерно с 20000 до 140000. Таким образом, кластеризация данных в случае с большими данными помогает оптимизировать запрос, но, в данном случае, несущественно.